# -*- coding: utf-8 -*-
"""NeuralNetwork.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CQ_A1jUCtiE4ZeTKu5JQdDS2sFVScDqR
"""

import numpy as np
from NeuralNetworkOptimizer import *
from NeuralNetworkLayer import *

class NeuralNetwork():
    def __init__(self):
        #ネットワークの情報のリスト
        self.data                     = []
        #ネットワークの実体のリスト
        self.layer                    = []
        #実装済みの活性化関数のリスト
        self.activation_function_list = ["Swish", "ReLU", "Sigmoid"]
        #実装済みの出力層のリスト
        self.output_layer_list        = ["Softmax2CrossEntropy"]
        #実装済みの最適化手法のリスト
        self.optimizer_list           = ["SDG", "Adam", "Momentum", "AdaGrad"]
        #ネットワークの層数を保持する変数
        self.length                   = 0
        #add_output_layerメソッドが呼び出されたかを保持するフラッグ
        self.output_flag              = False


    #構成したニューラルネットの情報をprint関数で表示
    def __repr__(self):
        pass

    #ニューラルネットに活性化関数を加えるメソッド
    def add_activation_function(self, func, size):
        #前のレイヤーが存在するか判定する。
        #存在するとき。
        if self.length > 0:
            #前のレイヤーがOutput層かどうか判定する。
            #Output層であったときエラーを吐く。
            if self.data[self.length - 1]["OUTFLAG"]:
                raise Exception("you cannot push more layer.")

            #Output層でなかったとき。
            else:
                #前のレイヤーの出力数とニューロンの数が一致するか判定する。
                #一致する。
                if self.data[self.length - 1]["SIZE"] == size or self.data[self.length - 1]["SIZE"][1] == size:
                    #funcの値が実装済みの活性化関数のリストに存在するか判定する。
                    #存在するとき。
                    if func in self.activation_function_list:
                        #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                        self.data.append({"LAYER":func, "SIZE":size, "OUTFLAG":False, "OPTIMIZER":None})

                    #存在しないときエラー吐く。
                    else:
                        raise Exception("func of arg has to be a string in NeuralNetwork.activation_function_list.")

                #一致しないときエラー吐く。
                else:
                    raise Exception("size of arg has to be appropriate value.")
        #存在しないとき。
        elif self.length == 0:
            #funcの値が実装済みの活性化関数のリストに存在するか判定する。
            #存在するとき。
            if func in self.activation_function_list:
                #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                self.data.append({"LAYER":func, "SIZE":size, "OUTFLAG":False, "OPTIMIZER":None})

            #存在しないときエラー吐く。
            else:
                raise Exception("func of arg has to be a string in NeuralNetwork.activation_function_list.")

        #層数を一つ増やす。
        self.length += 1

    #ニューラルネットに全結合層(Affine層)を加えるメソッド
    def add_affine(self, input, output, optimizer, lr = 0.01, arg1 = None, arg2 = None):
        #前のレイヤーが存在するか判定する。
        #存在するとき。
        if self.length > 0:
            #前のレイヤーがOutput層かどうか判定する。
            #Output層であったときエラーを吐く。
            if self.data[self.length - 1]["OUTFLAG"]:
                raise Exception("you cannot push more layer.")

            #Output層でなかったとき。
            else:
                #前のレイヤーの出力数と入力数が一致するか判定する。
                #一致する。
                if self.data[self.length - 1]["SIZE"] == input or self.data[self.length - 1]["SIZE"][1] == input:
                    #optimizerの値が実装済みの最適化手法のリストに存在するか判定する。
                    #存在するとき。
                    if optimizer in self.optimizer_list:
                        #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                        self.data.append({"LAYER":"Affine", "SIZE":(input,output), "OPTIMIZER":optimizer, "LR":lr, "ARG1":arg1, "ARG2":arg2, "OUTFLAG":False})

                    #存在しないときエラー吐く。
                    else:
                        raise Exception("optimizer of arg has to be a string in NeuralNetwork.optimizer_list.")

                #一致しないときエラー吐く。
                else:
                    raise Exception("size of arg has to be appropriate value.")

        #存在しないとき。
        else:
            #optimizerの値が実装済みの最適化手法のリストに存在するか判定する。
            #存在するとき。
            if optimizer in self.optimizer_list:
                #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                self.data.append({"LAYER":"Affine", "SIZE":(input,output), "OPTIMIZER":optimizer, "LR":lr, "ARG1":arg1, "ARG2":arg2, "OUTFLAG":False})

            #存在しないときエラー吐く。
            else:
                raise Exception("optimizer of arg has to be a string in NeuralNetwork.optimizer_list.")
        
        #層数を一つ増やす。
        self.length += 1

    #ニューラルネットにBatch Norm層を加えるメソッド
    def add_batch_norm(self, size, optimizer, lr = 0.01, arg1 = None, arg2 = None):
        #前のレイヤーが存在するか判定する。
        #存在するとき。
        if self.length > 0:
            #前のレイヤーがOutput層かどうか判定する。
            #Output層であったときエラーを吐く。
            if self.data[self.length - 1]["OUTFLAG"]:
                raise Exception("you cannot push more layer.")

            #Output層でなかったとき。
            else:
                #前のレイヤーの出力数と入力数が一致するか判定する。
                #一致する。
                if self.data[self.length - 1]["SIZE"] == size or self.data[self.length - 1]["SIZE"][1] == size:
                    #optimizerの値が実装済みの最適化手法のリストに存在するか判定する。
                    #存在するとき。
                    if optimizer in self.optimizer_list:
                        #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                        self.data.append({"LAYER":"BatchNorm", "SIZE":size, "OPTIMIZER":optimizer, "LR":lr, "ARG1":arg1, "ARG2":arg2, "OUTFLAG":False})

                    #存在しないときエラー吐く。
                    else:
                        raise Exception("optimizer of arg has to be a string in NeuralNetwork.optimizer_list.")

                #一致しないときエラー吐く。
                else:
                    raise Exception("size of arg has to be appropriate value.")

        #存在しないとき。
        else:
            #optimizerの値が実装済みの最適化手法のリストに存在するか判定する。
            #存在するとき。
            if optimizer in self.optimizer_list:
                #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                self.data.append({"LAYER":"BatchNorm", "SIZE":size, "OPTIMIZER":optimizer, "LR":lr, "ARG1":arg1, "ARG2":arg2, "OUTFLAG":False})

            #存在しないときエラー吐く。
            else:
                raise Exception("optimizer of arg has to be a string in NeuralNetwork.optimizer_list.")
        
        #層数を一つ増やす。
        self.length += 1

    #ニューラルネットにOutput層を加えるメソッド
    def add_output_layer(self, func, size):
        #前のレイヤーが存在するか判定する。
        #存在するとき。
        if self.length > 0:
            #前のレイヤーがOutput層かどうか判定する。
            #Output層であったときエラーを吐く。
            if self.data[self.length - 1]["OUTFLAG"]:
                raise Exception("you cannot push more layer.")

            #Output層でなかったとき。
            else:
                #前のレイヤーの出力数とニューロンの数が一致するか判定する。
                #一致する。
                if self.data[self.length - 1]["SIZE"] == size or self.data[self.length - 1]["SIZE"][1] == size:
                    #funcの値が実装済みの出力層のリストに存在するか判定する。
                    #存在するとき。
                    if func in self.output_layer_list:
                        #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                        self.data.append({"LAYER":func, "SIZE":size, "OUTFLAG":True, "OPTIMIZER":None})

                    #存在しないときエラー吐く。
                    else:
                        raise Exception("func of arg has to be a string in NeuralNetwork.activation_function_list.")

                #一致しないときエラー吐く。
                else:
                    raise Exception("size of arg has to be appropriate value.")
        #存在していないとき。
        elif self.length == 0:
            #funcの値が実装済みの出力層のリストに存在するか判定する。
            #存在するとき。
            if func in self.output_layer_list:
                #レイヤーの情報のディクショナリを作ってself.dataにappendする。
                self.data.append({"LAYER":func, "SIZE":size, "OUTFLAG":True, "OPTIMIZER":None})

            #存在しないときエラー吐く。
            else:
                raise Exception("func of arg has to be a string in NeuralNetwork.activation_function_list.")

        #層数を一つ増やす。
        self.length     += 1
        #このメソッドが呼び出されたフラグをTrueに変更する。
        self.output_flag = True

    #設定した情報からニューラルネットの実体を作るメソッド
    def create(self):
        #add_output_layerが呼び出されているか判定する。
        #呼び出されている。
        if self.output_flag:
            #層の数だけ繰り返す。
            for i in range(self.length):
                #空の辞書を作る。
                dict = {}

                #data[i]["LAYER"]が"Swish"ならdict["LAYER"] = Swish()
                if self.data[i]["LAYER"] == "Swish":
                    dict["LAYER"] = Swish()

                #data[i]["LAYER"]が"ReLU"ならdict["LAYER"] = ReLU()
                if self.data[i]["LAYER"] == "ReLU":
                    dict["LAYER"] = ReLU()

                #data[i]["LAYER"]が"Sigmoid"ならdict["LAYER"] = Sigmoid()
                if self.data[i]["LAYER"] == "Sigmoid":
                    dict["LAYER"] = Sigmoid()

                #data[i]["LAYER"]が"Softmax2CrossEntropy"ならdict["LAYER"] = Softmax2CrossEntropy()
                if self.data[i]["LAYER"] == "Softmax2CrossEntropy":
                    dict["LAYER"] = Softmax2CrossEntropy()

                #data[i]["LAYER"]が"Affine"ならdict["LAYER"] = Affine(data[i]["IN"], data[i]["OUT"])
                if self.data[i]["LAYER"] == "Affine":
                    dict["LAYER"] = Affine(self.data[i]["SIZE"][0], self.data[i]["SIZE"][1])

                #data[i]["LAYER"]が"BatchNorm"ならdict["LAYER"] = BatchNorm()
                if self.data[i]["LAYER"] == "BatchNorm":
                    dict["LAYER"] = BatchNorm(self.data[i]["SIZE"])

                #data[i]["OPTIMIZER"]がNoneならdict["OPTIMIZER"] = None
                if self.data[i]["OPTIMIZER"] is None:
                    dict["OPTIMIZER"] = None

                if not self.data[i]["OPTIMIZER"] is None:
                    #data[i]["OPTIMIZER"]が"SDG"ならdict["OPTIMIZER"] = SDG(lr = data[i]["LR"])
                    if self.data[i]["OPTIMIZER"] == "SDG":
                        dict["OPTIMIZER"] = SDG(lr = self.data[i]["LR"])

                    #data[i]["OPTIMIZER"]が"Momentum"ならdict["OPTIMIZER"] = Momentum(lr = data[i]["LR"], rv = data[i]["ARG1"])
                    if self.data[i]["OPTIMIZER"] == "Momentum":
                        dict["OPTIMIZER"] = Momentum(lr = self.data[i]["LR"], rv = self.data[i]["ARG1"])

                    #data[i]["OPTIMIZER"]が"AdaGrad"ならdict["OPTIMIZER"] = AdaGrad(lr = data[i]["LR"])
                    if self.data[i]["OPTIMIZER"] == "AdaGrad":
                        dict["OPTIMIZER"] = AdaGrad(lr = self.data[i]["LR"])

                    #data[i]["OPTIMIZER"]が"Adam"ならdict["OPTIMIZER"] = Adam(lr = data[i]["LR"], beta1 = data[i]["ARG1"], beta2 = data[i]["ARG2"])
                    if self.data[i]["OPTIMIZER"] == "Adam":
                        dict["OPTIMIZER"] = Adam(lr = self.data[i]["LR"], beta1 = self.data[i]["ARG1"], beta2 = self.data[i]["ARG2"])
                    
                #dictをself.layerにappend
                self.layer.append(dict)

        #呼び出されていないときエラーを吐く。
        else:
            raise Exception("you have to run add_output_layer method.")
        

    #各レイヤーのforwardメソッドを回すメソッド
    def forward(self, x, t):
        input = x
        
        for i in range(self.length - 1):
            input = self.layer[i]["LAYER"].forward(input)

        return self.layer[self.length - 1]["LAYER"].forward(input, t)

    #各レイヤーのbackwardメソッドを回すメソッド
    def backward(self):
        delta = self.layer[self.length - 1]["LAYER"].backward()

        for i in range(self.length - 2, -1, -1):
            delta = self.layer[i]["LAYER"].backward(delta)

        for j in range(self.length):
            if not self.layer[i]["OPTIMIZER"] is None:
                self.layer[i]["OPTIMIZER"].learning(self.layer[i]["LAYER"].W, self.layer[i]["LAYER"].dW, self.layer[i]["LAYER"].b, self.layer[i]["LAYER"].db) 

            elif self.layer[i]["OPTIMIZER"] is None:
                pass

    #テストデータで認識精度を出すメソッド
    def accuracy(self, x, t):
        z = x
        for i in range(self.length):
            z = self.layer[i]["LAYER"].test_forward(z)

        a = np.argmax(z, axis = 1)
        b = np.argmax(t, axis = 1)
        accuracy = float(np.sum(a == b))/float(x.shape[0])

        return accuracy

    #ニューラルネットの情報と学習したパラメータを.py外部ファイルに書き出すメソッド
    def save(self):
        pass

    #saveメソッドで書き出された.pyファイルを読み込むメソッド
    def load(self, file):
        pass